-- 1. Limpeza de dependências e funções
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.is_admin() CASCADE;
DROP VIEW IF EXISTS public.user_profiles_view CASCADE;

-- 2. Exclusão de todas as tabelas de dados (CASCADE para garantir)
DROP TABLE IF EXISTS public.transactions CASCADE;
DROP TABLE IF EXISTS public.services CASCADE;
DROP TABLE IF EXISTS public.vehicles CASCADE;
DROP TABLE IF EXISTS public.clients CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 3. Recriação do esquema de Perfis (Auth)
CREATE TABLE public.profiles (
  id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  role TEXT,
  avatar_url TEXT,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (id)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- 4. Recriação da função is_admin
CREATE OR REPLACE FUNCTION public.is_admin()
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.profiles
    WHERE id = auth.uid() AND role = 'Administrador'
  );
$function$;

-- 5. Recriação das políticas de RLS para profiles
CREATE POLICY "profiles_select_policy" ON public.profiles 
FOR SELECT TO authenticated USING (auth.uid() = id);
CREATE POLICY "profiles_insert_policy" ON public.profiles 
FOR INSERT TO authenticated WITH CHECK (auth.uid() = id);
CREATE POLICY "profiles_update_policy" ON public.profiles 
FOR UPDATE TO authenticated USING (auth.uid() = id);
CREATE POLICY "profiles_delete_policy" ON public.profiles 
FOR DELETE TO authenticated USING (auth.uid() = id);
CREATE POLICY "Administrators can view all profiles" ON public.profiles 
FOR SELECT TO authenticated USING (is_admin());

-- 6. Recriação da view user_profiles_view
CREATE OR REPLACE VIEW public.user_profiles_view AS
 SELECT p.id,
    p.full_name,
    p.role,
    a.email,
    p.avatar_url
   FROM public.profiles p
     JOIN auth.users a ON p.id = a.id;

-- 7. Recriação da função handle_new_user e trigger
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE PLPGSQL
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role, avatar_url)
  VALUES (
    new.id, 
    new.raw_user_meta_data ->> 'full_name', 
    new.raw_user_meta_data ->> 'role',
    new.raw_user_meta_data ->> 'avatar_url'
  );
  RETURN new;
END;
$$;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 8. Recriação da tabela clients e RLS
CREATE TABLE public.clients (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  cpf_cnpj TEXT,
  email TEXT,
  phone TEXT,
  address TEXT,
  avatar_url TEXT,
  doc_status TEXT,
  client_type TEXT,
  marital_status TEXT,
  profession TEXT,
  nationality TEXT,
  naturalness TEXT,
  cnh_expiration_date DATE,
  trade_name TEXT,
  contact_name TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Agências podem gerenciar seus próprios clientes" ON public.clients 
FOR ALL TO authenticated USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- 9. Recriação da tabela vehicles e RLS
CREATE TABLE public.vehicles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  owner_id BIGINT NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  plate TEXT NOT NULL,
  chassis TEXT,
  renavam TEXT,
  brand TEXT,
  model TEXT,
  year_manufacture INTEGER,
  year_model INTEGER,
  color TEXT,
  fuel_type TEXT,
  licensing_expiration_date DATE,
  image_urls TEXT[],
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.vehicles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Agências podem gerenciar seus próprios veículos" ON public.vehicles 
FOR ALL TO authenticated USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- 10. Recriação da tabela services e RLS
CREATE TABLE public.services (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id BIGINT NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  vehicle_id BIGINT NOT NULL REFERENCES public.vehicles(id) ON DELETE CASCADE,
  payer_client_id BIGINT REFERENCES public.clients(id),
  name TEXT NOT NULL,
  status TEXT,
  due_date DATE,
  price NUMERIC,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Agências podem gerenciar seus próprios serviços" ON public.services 
FOR ALL TO authenticated USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- 11. Recriação da tabela transactions e RLS
CREATE TABLE public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  client_id BIGINT REFERENCES public.clients(id),
  service_id BIGINT REFERENCES public.services(id),
  description TEXT NOT NULL,
  category TEXT,
  date DATE NOT NULL,
  due_date DATE,
  amount NUMERIC NOT NULL,
  type TEXT NOT NULL,
  status TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Agências podem gerenciar suas próprias transações" ON public.transactions 
FOR ALL TO authenticated USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);